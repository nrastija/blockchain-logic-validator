// ==========================================
// ALL-IN-ONE Blockchain KB (Flora-2)
// Author: Niko Rastija
// Date: 07/01/2026
// ==========================================

// =====================
// 1) SHEMA (KLASE)
// =====================

transaction::class[
    tx_id => string,
sender_address => address,
recipient_address => address,
amount => decimal,
timestamp => integer,
digital_signature => string
].

address::class[
    id => string,
balance => decimal
].

block::class[
    index => integer,
timestamp => integer,
transactions => list,
previous_hash => string,
hash => string,
nonce => integer
].

// =====================
// 2) TESTNI PODACI
// =====================

// Addresses
marko:address[id -> 'marko', balance -> 1000.0].
janica:address[id -> 'janica', balance -> 500.0].
niko:address[id -> 'niko', balance -> 750.0].
elizabeta:address[id -> 'elizabeta', balance -> 0.0].
james:address[id -> 'james', balance -> 250.0].
coinbase:address[id -> 'coinbase', balance -> 999999.0].

// Transactions (valid examples)
tx1:transaction[
    tx_id -> 'tx1',
sender_address -> marko,
recipient_address -> janica,
amount -> 50.0,
timestamp -> 1767779951,
digital_signature -> 'sig_marko_tx1'
].

tx2:transaction[
    tx_id -> 'tx2',
sender_address -> niko,
recipient_address -> james,
amount -> 300.0,
timestamp -> 1767780172,
digital_signature -> 'sig_niko_tx2'
].

tx8:transaction[
    tx_id -> 'tx8',
sender_address -> james,
recipient_address -> marko,
amount -> 100.0,
timestamp -> 1767780413,
digital_signature -> 'sig_james_tx8'
].

// Transactions (invalid examples)
tx3:transaction[
    tx_id -> 'tx3',
sender_address -> elizabeta,
recipient_address -> niko,
amount -> 500.0,
timestamp -> 1767780626,
digital_signature -> 'sig_elizabeta_tx3'
].

tx4:transaction[
    tx_id -> 'tx4',
sender_address -> marko,
recipient_address -> james,
amount -> -50.0,
timestamp -> 1767787835,
digital_signature -> 'sig_marko_tx4'
].

tx5:transaction[
    tx_id -> 'tx5',
sender_address -> janica,
recipient_address -> janica,
amount -> 30.0,
timestamp -> 1767787919,
digital_signature -> 'sig_janica_tx5'
].

tx6:transaction[
    tx_id -> 'tx6',
sender_address -> marko,
recipient_address -> james,
amount -> 40.0,
timestamp -> 1767788020,
digital_signature -> 'fake_signature'
].

tx7:transaction[
    tx_id -> 'tx7',
sender_address -> elizabeta,
recipient_address -> niko,
amount -> 0.0,
timestamp -> 1767788113,
digital_signature -> 'sig_elizabeta_tx7'
].

// Blocks
genesis_block:block[
    index -> 0,
timestamp -> 1767788222,
transactions -> [],
previous_hash -> '0',
hash -> 'genesis_hash_00000',
nonce -> 0
].

block1:block[
    index -> 1,
timestamp -> 1767788322,
transactions -> [tx1, tx2],
previous_hash -> 'genesis_hash_00000',
hash -> 'block1_hash_00000',
nonce -> 12345
].

block2:block[
    index -> 2,
timestamp -> 1767788396,
transactions -> [tx7],
previous_hash -> 'block1_hash_00000',
hash -> 'block2_hash_00000',
nonce -> 23456
].

all_transactions([tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8]).

// =====================
// 3) POMOĆNI PREDIKATI ZA LISTE (bez Prolog member)
// =====================

member_list(?X, [?X | ?_]).
member_list(?X, [?_ | ?T]) :- member_list(?X, ?T).

length_list([], 0).
length_list([?_ | ?T], ?N) :-
length_list(?T, ?N1),
?N \is ?N1 + 1.

// =====================
// 4) PRAVILA VALIDACIJE
// =====================

// Rule 1: Amount has to be positive
positive_amount(?Tx) :-
?Tx:transaction[amount -> ?A],
?A > 0.

// Rule 2: sender != recipient
different_addresses(?Tx) :-
?Tx:transaction[sender_address -> ?S, recipient_address -> ?R],
?S !== ?R.

// Rule 3: sufficient balance
sufficient_balance(?Tx) :-
?Tx:transaction[sender_address -> ?S, amount -> ?A],
?S:address[balance -> ?B],
?B >= ?A.

// Rule 4: signature valid (starts with sig_ + sender id)
valid_signature(?Tx) :-
?Tx:transaction[sender_address -> ?S, digital_signature -> ?Sig],
?S:address[id -> ?SenderId],
atom_concat('sig_', ?SenderId, ?Prefix)@\plg,
sub_atom(?Sig, 0, ?Len, ?After, ?Prefix)@\plg.

// Rule 5: not double spent (tx_id not already present in any block)
not_double_spent(?Tx) :-
?Tx:transaction[tx_id -> ?TxID],
\naf spent_transaction(?TxID).

spent_transaction(?TxID) :-
?_B:block[transactions -> ?TxList],
member_list(?T, ?TxList),
?T:transaction[tx_id -> ?TxID].

double_spend_risk(?Tx) :-
\naf(not_double_spent(?Tx)).

// MAIN: valid transaction (wrapper to avoid HiLog issues)
is_valid_transaction(?Tx) :-
?Tx:transaction,
positive_amount(?Tx),
different_addresses(?Tx),
sufficient_balance(?Tx),
valid_signature(?Tx).

valid_transaction(?Tx) :-
is_valid_transaction(?Tx).

// =====================
// 5) DIJAGNOSTIKA (ZAŠTO JE TRANSAKCIJA FAIL)
// =====================

diagnose_transaction(?Tx, insufficient_funds) :-
\naf sufficient_balance(?Tx),
!.

diagnose_transaction(?Tx, negative_or_zero_amount) :-
\naf positive_amount(?Tx),
!.

diagnose_transaction(?Tx, same_sender_receiver) :-
\naf different_addresses(?Tx),
!.

diagnose_transaction(?Tx, invalid_signature) :-
\naf valid_signature(?Tx),
!.

diagnose_transaction(?Tx, valid) :-
valid_transaction(?Tx),
!.

diagnose_transaction(_, unknown_error).

// =====================
// 6) BLOKOVI (VALIDACIJA TRANSAKCIJA U BLOKU)
// =====================

valid_block_transactions(?Block) :-
?Block:block[transactions -> ?TxList],
all_valid_in_list(?TxList).

all_valid_in_list([]).
all_valid_in_list([?Tx | ?Rest]) :-
valid_transaction(?Tx),
all_valid_in_list(?Rest).

// =====================
// 7) ANALIZA I STATISTIKA
// =====================

// Elegantno prebrojavanje (Gemini-style)
network_health(?Total, ?Valid, ?Invalid, ?Score) :-
?Total = count{?Tx | ?Tx:transaction},
?Valid = count{?T2 | valid_transaction(?T2)},
?Invalid \is ?Total - ?Valid,
calculate_score(?Total, ?Valid, ?Score).

calculate_score(?Total, ?Valid, ?Score) :-
?Total > 0,
!,
?Score \is (?Valid * 100.0) / ?Total.
calculate_score(0, 0, 0).

// Liste valid/invalid (bez findall)
all_valid_transactions(?List) :-
all_transactions(?All),
valid_from_list(?All, ?List).

valid_from_list([], []).
valid_from_list([?Tx | ?Rest], [?Tx | ?Out]) :-
valid_transaction(?Tx),
valid_from_list(?Rest, ?Out).
valid_from_list([?Tx | ?Rest], ?Out) :-
\naf valid_transaction(?Tx),
valid_from_list(?Rest, ?Out).

all_invalid_transactions(?List) :-
all_transactions(?All),
invalid_from_list(?All, ?List).

invalid_from_list([], []).
invalid_from_list([?Tx | ?Rest], [?Tx | ?Out]) :-
\naf valid_transaction(?Tx),
invalid_from_list(?Rest, ?Out).
invalid_from_list([?Tx | ?Rest], ?Out) :-
valid_transaction(?Tx),
invalid_from_list(?Rest, ?Out).

data_stats :-
?AddrCount = count{?A | ?A:address},
?TxCount   = count{?T | ?T:transaction},
write('Adrese u bazi: ')@\io, write(?AddrCount)@\io, nl@\io,
write('Transakcije u bazi: ')@\io, write(?TxCount)@\io, nl@\io.

// ====================
// 8) HELP + QUICK TEST
// =====================

help :-
nl@\io,
write('Dostupne naredbe:')@\io, nl@\io,
nl@\io,

write('Provjera valjanosti:')@\io, nl@\io,
write('  valid_transaction(tx1).')@\io,
write('   - Provjerava je li transakcija tx1 valjana prema osnovnim pravilima.')@\io, nl@\io,

write('  diagnose_transaction(tx3, ?Problem).')@\io,
write('   - Objašnjava zasto transakcija tx3 nije valjana (ili je valjana).')@\io, nl@\io,
nl@\io,

write('Adrese:')@\io, nl@\io,
write('  marko:address[balance -> ?B].')@\io,
write('   - Dohvaća trenutno stanje (balance) adrese marko.')@\io, nl@\io,
nl@\io,

write('Transakcije:')@\io, nl@\io,
write('  ?Tx:transaction[sender_address -> marko].')@\io,
write('   - Ispisuje sve transakcije koje je poslala adresa marko.')@\io, nl@\io,
nl@\io,

write('Analiza:')@\io, nl@\io,
write('  all_valid_transactions(?List).')@\io,
write('   - Vraća popis svih valjanih transakcija u sustavu.')@\io, nl@\io,

write('  all_invalid_transactions(?List).')@\io,
write('   - Vraća popis svih nevaljanih transakcija u sustavu.')@\io, nl@\io,

write('  double_spend_risk(tx1).')@\io,
write('   - Provjerava postoji li rizik dvostrukog trošenja za transakciju tx1.')@\io, nl@\io,

write('  network_health(?T, ?V, ?I, ?S).')@\io,
write('   - Izračunava ukupno stanje mreže (ukupno, valjane, nevaljane transakcije i postotak ispravnosti).')@\io, nl@\io,
nl@\io,

write('Blokovi:')@\io, nl@\io,
write('  valid_block_transactions(block1).')@\io,
write('   - Provjerava jesu li sve transakcije unutar bloka block1 valjane.')@\io, nl@\io,
nl@\io,

write('Statistika:')@\io, nl@\io,
write('  data_stats.')@\io,
write('   - Ispisuje osnovnu statistiku o adresama i transakcijama u bazi znanja.')@\io, nl@\io,
nl@\io.


quick_test :-
nl@\io,
write('Running tests...')@\io, nl@\io,
nl@\io,

write('Test 1: tx1 should be valid')@\io, nl@\io,
( ( valid_transaction(tx1), write('  PASS')@\io, ! )
;
( write('  FAIL')@\io )
),
nl@\io, nl@\io,

write('Test 2: tx3 should be invalid (insufficient funds)')@\io, nl@\io,
( ( \naf(valid_transaction(tx3)), write('  PASS')@\io, ! )
;
( write('  FAIL')@\io )
),
nl@\io,
diagnose_transaction(tx3, ?P3),
write('  Reason: ')@\io, write(?P3)@\io, nl@\io,
nl@\io,

write('Test 3: tx4 should be invalid (negative amount)')@\io, nl@\io,
( ( \naf(valid_transaction(tx4)), write('  PASS')@\io, ! )
;
( write('  FAIL')@\io )
),
nl@\io,
diagnose_transaction(tx4, ?P4),
write('  Reason: ')@\io, write(?P4)@\io, nl@\io,
nl@\io,

write('Test 4: Network health')@\io, nl@\io,
network_health(?T, ?V, ?I, ?S),
write('  Total: ')@\io, write(?T)@\io, nl@\io,
write('  Valid: ')@\io, write(?V)@\io, nl@\io,
write('  Invalid: ')@\io, write(?I)@\io, nl@\io,
write('  Score: ')@\io, write(?S)@\io, write('%')@\io, nl@\io,
nl@\io,

write('Tests completed')@\io, nl@\io,
nl@\io.

